<?php
/**
 * Authenticates clients that make requests to the BTS API. Almost all requests
 * contain the system name of the client and an HMAC signature of the request
 * (using the private API key as a key) which are verified in this class.
 *
 * @author	Frederick Ding
 * @version	$Id$
 */
class Api_Model_ClientAuthentication
{
	/**
	 * An instance of the database adapter.
	 * @var Zend_Db_Adapter_Abstract
	 */
	private $db = null;
	/**
	 * Performs a few initialization actions: loads the database adapter from
	 * the resource stored in Zend_Registry.
	 */
	public function __construct ()
	{
		// get the database resource that was defined from Zend_Application
		if (Zend_Registry::isRegistered('db')) {
			$this->db = Zend_Registry::get('db')->getDbAdapter();
		}
		// we can't proceed without a valid adapter
		if (is_null($this->db)) {
			throw new Zend_Db_Adapter_Exception(
				'Database adapter could not be built');
		}
		$this->db->getConnection();
	}
	/**
	 * Fetches the API key of the given API client from the database.
	 * @param string $sysName
	 * @return string
	 */
	private function getApiKey ($sysName)
	{
		$query = $this->db->select()->from('bts_clients', 'api_key')
		->where('sys_name = ?', $sysName)
		->where('status = 1')
		->limit(1)
		->query()->fetchColumn();
		return $query;
	}
	/**
	 * Checks the timestamp supplied with a request to see whether it is within
	 * 15 minutes to prevent replay attacks. Unfortunately, this has to be done
	 * using MySQL functions for now.
	 * @param long $timestamp
	 * @return bool
	 */
	public function validateTimestamp($timestamp = 0)
	{
		// valid timestamps are less than 15 minutes from current GMT time
		// ABS(TIMESTAMPDIFF(MINUTE, ********* , NOW())) < 15
		if(!is_numeric($timestamp))
			return false;
		$query = $this->db->select()->from('',
			new Zend_Db_Expr('ABS(TIMESTAMPDIFF(MINUTE, ' . $timestamp . ' , UTC_TIMESTAMP())) < 15'))
		->query()->fetchColumn();
		return ($query == 1);
	}
	/**
	 * Generates a valid API request signature using the HMAC methodology using
	 * the specified request details.
	 *
	 * This can be considered a reference implementation for the BTS API signature
	 * specifications.
	 * @param string $httpVerb
	 * @param string $uri
	 * @param array $params
	 * @param string|null $apiKey
	 * @return string
	 * @throws Zend_Exception
	 */
	public function generateSignature($httpVerb, $uri, array $params, $apiKey = null)
	{
		// validate the HTTP verb
		$httpVerb = trim(strtoupper($httpVerb));
		if(!in_array($httpVerb, array('GET', 'POST')))
			throw new Zend_Exception('Invalid HTTP verb in generateSignature()');

		// create a message to sign with HMAC
		$stringToSign = $httpVerb . "\n";
		$stringToSign .= $uri . "\n";

		// parameters in key => value format must be in alpha order
		unset($params['signature']);
		ksort($params);

		// use the sysName in the params to get the API key if it is not specified
		if (is_null($apiKey)) {
			$apiKey = $this->getApiKey($params['sysName']);
			if ($apiKey === false) {
				throw new Zend_Exception(
					'Invalid sysName in generateSignature()');
			}
		}

		// concatenate the parameters to the HMAC message
		reset($params);
		while(list($key, $val) = each($params)) {
			$stringToSign .= $key . '=' . urlencode($val) . "\n";
		}

		// generate a HMAC hash using the API key as key, encoded using base64
		$digest = base64_encode(hash_hmac('sha1', $stringToSign, $apiKey, true));
		return $digest;
	}
	/**
	 * Validates a given signature by comparing it with a signature generated by
	 * our reference implementation.
	 *
	 * @param string $httpVerb
	 * @param string $uri
	 * @param array $params
	 * @return bool
	 */
	public function validateSignature ($httpVerb, $uri, array $params)
	{
		try {
			$generated = $this->generateSignature($httpVerb, $uri, $params);
		} catch (Zend_Exception $e) {
			return false;
		}
		return ($generated == $params['signature']);
	}
}