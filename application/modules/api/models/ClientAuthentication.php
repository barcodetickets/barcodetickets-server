<?php
/**
 * Authenticates clients that make requests to the BTS API. Almost all requests
 * contain the system name of the client and an HMAC signature of the request
 * (using the private API key as a key) which are verified in this class.
 *
 * @author	Frederick Ding
 * @version	$Id$
 */
class Api_Model_ClientAuthentication
{
	/**
	 *
	 * @var Bts_Model_DbTable_Clients
	 */
	private $table = null;
	/**
	 * Performs a few initialization actions: loads the database adapter from
	 * the resource stored in Zend_Registry.
	 */
	public function __construct ()
	{
		$this->table = new Bts_Model_DbTable_Clients();
	}
	/**
	 * Fetches the API key of the given API client from the database.
	 * @param string $sysName
	 * @return string
	 */
	private function getApiKey ($sysName)
	{
		$query = $this->table->getAdapter()->select()->from('bts_clients', 'api_key')->where('sys_name = ?', $sysName)->where('status = 1')->limit(1)->query()->fetchColumn();
		return $query;
	}
	private function getClientId ($sysName)
	{
		$query = $this->table->getAdapter()->select()->from('bts_clients', 'client_id')->where('sys_name = ?', $sysName)->limit(1)->query()->fetchColumn();
		return $query;
	}
	/**
	 * Checks the timestamp supplied with a request to see whether it is within
	 * 15 minutes to prevent replay attacks. Unfortunately, this has to be done
	 * using MySQL functions for now.
	 * @param long $timestamp
	 * @return bool
	 */
	public function validateTimestamp ($timestamp = 0)
	{
		// valid timestamps are less than 15 minutes from current GMT time
		// ABS(TIMESTAMPDIFF(MINUTE, ********* , NOW())) < 15
		if (! is_numeric($timestamp)) return false;
		$query = $this->table->getAdapter()->select()->from('', new Zend_Db_Expr(
			'ABS(TIMESTAMPDIFF(MINUTE, ' . $timestamp . ' , UTC_TIMESTAMP())) < 15'))->query()->fetchColumn();
		return ($query == 1);
	}
	/**
	 * Generates a valid API request signature using the HMAC methodology using
	 * the specified request details.
	 *
	 * This can be considered a reference implementation for the BTS API signature
	 * specifications.
	 * @param string $httpVerb
	 * @param string $uri
	 * @param array $params
	 * @param string|null $apiKey
	 * @return string
	 * @throws Bts_Exception
	 */
	public function generateSignature ($httpVerb, $uri, array $params, $apiKey = null)
	{
		// validate the HTTP verb
		$httpVerb = trim(strtoupper($httpVerb));
		if (! in_array($httpVerb, array(
			'GET' ,
			'POST'))) throw new Bts_Exception(
			'Invalid HTTP verb in generateSignature()');
		// create a message to sign with HMAC
		$stringToSign = $httpVerb . "\n";
		$stringToSign .= $uri . "\n";
		// parameters in key => value format must be in alpha order
		unset($params['signature']);
		ksort($params);
		// use the sysName in the params to get the API key if it is not specified
		if (is_null($apiKey)) {
			$apiKey = $this->getApiKey($params['sysName']);
			if ($apiKey === false) {
				throw new Bts_Exception(
					'Invalid sysName in generateSignature()');
			}
		}
		// concatenate the parameters to the HMAC message
		reset($params);
		while (list ($key, $val) = each($params)) {
			$stringToSign .= $key . '=' . urlencode($val) . "\n";
		}
		// generate a HMAC hash using the API key as key, encoded using base64
		$digest = base64_encode(hash_hmac('sha1', $stringToSign, $apiKey, true));
		return $digest;
	}
	/**
	 * Validates a given signature by comparing it with a signature generated by
	 * our reference implementation.
	 *
	 * @param string $httpVerb
	 * @param string $uri
	 * @param array $params
	 * @return bool
	 */
	public function validateSignature ($httpVerb, $uri, array $params)
	{
		try {
			$generated = $this->generateSignature($httpVerb, $uri, $params);
		} catch (Zend_Exception $e) {
			return false;
		}
		return ($generated == $params['signature']);
	}
	public function startSession (Bts_Model_Users $Users, $username, $password, $sysName)
	{
		if ($Users->checkPassword($username, $password)) {
			$client_id = $this->getClientId($sysName);
			$user_id = $Users->getUserId($username);
			$query = $this->table->getAdapter()->insert('bts_sessions', array(
				'session_id' => new Zend_Db_Expr(
					'UNHEX(SHA1(CONCAT_WS("-", ' . $client_id . ', ' . $user_id . ', UTC_TIMESTAMP())))') ,
				'client_id' => $client_id ,
				'user_id' => $user_id ,
				'expire_time' => new Zend_Db_Expr(
					'UTC_TIMESTAMP() + INTERVAL 2 HOUR')));
		}
	}
}