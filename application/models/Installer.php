<?php

/**
 * Installer model.
 *
 * Contains methods for setting up BTS server for the first time.
 *
 * @author	Frederick Ding
 * @package	Bts
 */
class Bts_Model_Installer
{

	public $tests = array(
			'php-version' => array(
					'PHP version',
					PHP_VERSION,
					PHP_VERSION
			),
			'php-safe' => array(
					'PHP safe mode',
					'off',
					'on'
			),
			'php-pear' => array(
					'PEAR',
					'installed',
					'not installed'
			),
			'ext-hash' => array(
					'Hash extension',
					'supported',
					'not supported'
			),
			'ext-json' => array(
					'JSON extension',
					'supported',
					'not supported'
			),
			'ext-mcrypt' => array(
					'mcrypt extension',
					'supported',
					'not supported'
			),
			'ext-pdo' => array(
					'PHP Data Objects',
					'supported',
					'not supported'
			),
			'ext-pdomysql' => array(
					'PDO MySQL',
					'supported',
					'not supported'
			),
			'ext-mysqli' => array(
					'MySQLi extension',
					'supported',
					'not supported'
			),
			'files-btsdist' => array(
					'bts.ini.dist file',
					'exists',
					'not found'
			),
			'files-dbdist' => array(
					'database.ini.dist',
					'exists',
					'not found'
			),
			'files-writable' => array(
					'Configuration files',
					'writable',
					'not writable'
			)
	);

	/**
	 * Generates a pseudorandom 256-bit installation hash.
	 *
	 * By default, it will try to use OpenSSL to make random bytes, but in case
	 * OpenSSL is unavailable, it falls back to a random-number-seeded hash of
	 * installation details. (The OpenSSL-generated bytes are used as-is; they
	 * are not further hashed.)
	 *
	 * In previous versions, installation instructions recommended using a
	 * 32-character (256-bit) human-readable ASCII string. This installer will
	 * instead produce a hex representation of a true 256-bit hash.
	 *
	 * @since 0.2.0
	 * @return string
	 */
	public function generateHash ()
	{
		$hash = '';
		if (extension_loaded('openssl') &&
				 version_compare(PHP_VERSION, '5.3.0', '>=')) {
			$hash = bin2hex(openssl_random_pseudo_bytes(32));
		} else {
			// fallback to sha256 of installation details + 32-char salt
			$plaintext = $_SERVER['SERVER_ADDR'] . $_SERVER['HTTP_HOST'] .
					 $_SERVER['SCRIPT_FILENAME'];
			// produce a 32-char salt using printable ASCII characters
			for ($i = 0; $i < 32; $i ++) {
				$plaintext .= chr(mt_rand(32, 126));
			}
			$hash = hash('sha256', $plaintext);
		}
		return $hash;
	}

	/**
	 * Runs a series of boolean tests that are required for installation.
	 *
	 * @return array
	 */
	public function testEnvironment ()
	{
		@include_once ('System.php');
		// for each test, TRUE = pass, FALSE = fail
		$tests = array(
				'php-version' => version_compare(PHP_VERSION, '5.3.0', '>='),
				'php-safe' => ! ((bool) ini_get('safe_mode')),
				'php-pear' => class_exists('System'),
				'ext-hash' => extension_loaded('hash'),
				'ext-json' => extension_loaded('json'),
				'ext-mcrypt' => extension_loaded('mcrypt'),
				'ext-pdo' => extension_loaded('pdo'),
				'ext-pdomysql' => extension_loaded('pdo_mysql'),
				'ext-mysqli' => extension_loaded('mysqli'),
				'files-btsdist' => @file_exists(
						APPLICATION_PATH . '/configs/bts.ini.dist'),
				'files-dbdist' => @file_exists(
						APPLICATION_PATH . '/configs/database.ini.dist'),
				'files-writable' => is_writable(APPLICATION_PATH . '/configs')
		);
		return $tests;
	}

	/**
	 * Looks up the readable text representation for a given test.
	 * 
	 * @param string $test        	
	 * @param bool $success        	
	 * @return array
	 */
	public function getTestReadable ($test, $success)
	{
		if (array_key_exists($test, $this->tests)) {
			$name = $this->tests[$test][0];
			$text = ($success ? $this->tests[$test][1] : $this->tests[$test][2]);
			return array(
					$name,
					$text
			);
		} else
			return array(
					'',
					''
			);
	}
}